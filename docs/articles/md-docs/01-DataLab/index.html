<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/prism.css /><link rel='stylesheet' href=../../../css/index.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <div class="header-navigator"><ul><li><a href="#h1-0">datalab</a><ul><li><a href="#h2-1">前言</a></li></ul><ul><li><a href="#h2-2">实验解答</a></li></ul><ul><li><a href="#h2-3">编译运行</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">datalab</h1><h2 id="h2-1">前言</h2><pre><code class="language-bash">tar xvf datalab-handout.tar</code></pre><p>解压缩之后可以看到本次实验使用的是gcc工具,打开Makefile文件可以看到使用了-m32进行了编译</p><p>所以如果在编译的时候报错了还需要安装32位的gcc编译器</p><pre><code class="language-bash">sudo apt-get install gcc-multilib</code></pre><p>位运算运算符优先级</p><table><tr><th>运算符</th><th>优先级</th></tr><tr><td style="text-align:center">                ()</td><td style="text-align:center">                1</td></tr><tr><td style="text-align:center">                -(单目) ! ~</td><td style="text-align:center">                2</td></tr><tr><td style="text-align:center">                * / %</td><td style="text-align:center">                3</td></tr><tr><td style="text-align:center">                + -</td><td style="text-align:center">                4</td></tr><tr><td style="text-align:center">                &lt&lt &gt&gt</td><td style="text-align:center">                5</td></tr><tr><td style="text-align:center">                &gt &gt= &lt &lt=</td><td style="text-align:center">                6</td></tr><tr><td style="text-align:center">                == !=</td><td style="text-align:center">                7</td></tr><tr><td style="text-align:center">                &</td><td style="text-align:center">                8</td></tr><tr><td style="text-align:center">                ^</td><td style="text-align:center">                9</td></tr><tr><td style="text-align:center">                |</td><td style="text-align:center">                10</td></tr></table><blockquote><p><a href="https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/4752611" target="_blank">完整运算符优先级</a></p></blockquote><h2 id="h2-2">实验解答</h2><pre><code class="language-c">int bitXor(int x, int y) {
  return ~(x&y)&~(~x&~y);
}
/*
 * tmin - return minimum two's complement integer
 Legal ops: ! ~ & ^ | + &lt;&lt; &gt;&gt;
 Max ops: 4
 Rating: 1
 */
int tmin(void) {
    return 1&lt;&lt;31;
}
//2
/*
 * isTmax - returns 1 if x is the maximum, two's complement number,
 and 0 otherwise
 Legal ops: ! ~ & ^ | +
 Max ops: 10
 Rating: 1
 */
int isTmax(int x) {
    return !((~(x+1)^x))&!!(x+1);
}
/*
 * allOddBits - return 1 if all odd-numbered bits in word set to 1
 where bits are numbered from 0 (least significant) to 31 (most significant)
 Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1
 Legal ops: ! ~ & ^ | + &lt;&lt; &gt;&gt;
 Max ops: 12
 Rating: 2
 */
int allOddBits(int x) {
    int mask = 0xaa | 0xaa &lt;&lt; 8;
    mask = mask | mask &lt;&lt; 16;
    return !((x&mask)^mask);
}
/*
 * negate - return -x
 Example: negate(1) = -1.
 Legal ops: ! ~ & ^ | + &lt;&lt; &gt;&gt;
 Max ops: 5
 Rating: 2
 */
int negate(int x) {
    return ~x+1;
}
//3
/*
 * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9')
 Example: isAsciiDigit(0x35) = 1.
 isAsciiDigit(0x3a) = 0.
 isAsciiDigit(0x05) = 0.
 Legal ops: ! ~ & ^ | + &lt;&lt; &gt;&gt;
 Max ops: 15
 Rating: 3
 */
int isAsciiDigit(int x) {
    int first_match = !(x&gt;&gt;4^3);
    int second_match = (~0xa+1+(x&0xf))&gt;&gt;31&1;
    return first_match & second_match;
}
/*
 * conditional - same as x ? y : z
 Example: conditional(2,4,5) = 4
 Legal ops: ! ~ & ^ | + &lt;&lt; &gt;&gt;
 Max ops: 16
 Rating: 3
 */
int conditional(int x, int y, int z) {
    int mask = !x + ~0;
    return (mask & y) | (~mask &z);
}
/*
 * isLessOrEqual - if x &lt;= y  then return 1, else return 0
 Example: isLessOrEqual(4,5) = 1.
 Legal ops: ! ~ & ^ | + &lt;&lt; &gt;&gt;
 Max ops: 24
 Rating: 3
 */
int isLessOrEqual(int x, int y) {
    int judge = !((y+~x+1)&gt;&gt;31);
    int same_signal = !((x^y)&gt;&gt;31);
    int x_neg_y_pos = (x&gt;&gt;31)&!(y&gt;&gt;31);
    return x_neg_y_pos | (same_signal & judge);
}
//4
/*
 * logicalNeg - implement the ! operator, using all of
 the legal operators except !
 Examples: logicalNeg(3) = 0, logicalNeg(0) = 1
 Legal ops: ~ & ^ | + &lt;&lt; &gt;&gt;
 Max ops: 12
 Rating: 4
 */
int logicalNeg(int x) {
    int a = (x&(~x+1));
    int b = a + ~0;
    int c = b &gt;&gt; 31;
    return ~c + 1;
}
/* howManyBits - return the minimum number of bits required to represent x in
 two's complement
 Examples: howManyBits(12) = 5
 howManyBits(298) = 10
 howManyBits(-5) = 4
 howManyBits(0)  = 1
 howManyBits(-1) = 1
 howManyBits(0x80000000) = 32
 Legal ops: ! ~ & ^ | + &lt;&lt; &gt;&gt;
 Max ops: 90
 Rating: 4
 */
int howManyBits(int x) {
    int b16,b8,b4,b2,b1,b0;
    int flag = x&gt;&gt;31;
    x = (flag&~x) | (~flag&x); //x为非正数则不变 ,x 为负数 则相当于按位取反
    b16 = !!(x&gt;&gt;16) &lt;&lt;4; //如果高16位不为0,则我们让b16=16
    x&gt;&gt;=b16; //如果高16位不为0 则我们右移动16位 来看高16位的情况
    //下面过程基本类似
    b8=!!(x&gt;&gt;8)&lt;&lt;3;
    x &gt;&gt;= b8;
    b4 = !!(x &gt;&gt; 4) &lt;&lt; 2;
    x &gt;&gt;= b4;
    b2 = !!(x &gt;&gt; 2) &lt;&lt; 1;
    x &gt;&gt;= b2;
    b1 = !!(x &gt;&gt; 1);
    x &gt;&gt;= b1;
    b0 = x;
    return b0+b1+b2+b4+b8+b16+1;
}
//float
/*
 * floatScale2 - Return bit-level equivalent of expression 2*f for
 floating point argument f.
 Both the argument and result are passed as unsigned int's, but
 they are to be interpreted as the bit-level representation of
 single-precision floating point values.
 When argument is NaN, return argument
 Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while
 Max ops: 30
 Rating: 4
 */
unsigned floatScale2(unsigned uf) {
    int exp_mask = 0x7f800000;
    int exp = (uf&exp_mask)&gt;&gt;23;
    int frac_mask = 0x7fffff;
    int frac = uf & frac_mask;
    if (exp == 0) {
        if (frac&gt;&gt;23&1) {
            frac = frac * 2 - 0x7fffff;
        } else {
            frac = frac &lt;&lt; 1;
        }
        return (uf & ~frac_mask) | frac;
    } else if (exp == 255) {
        return uf;
    } else {
        return (uf & ~exp_mask) | (exp+1)&lt;&lt;23;
    }
}
/*
 * floatFloat2Int - Return bit-level equivalent of expression (int) f
 for floating point argument f.
 Argument is passed as unsigned int, but
 it is to be interpreted as the bit-level representation of a
 single-precision floating point value.
 Anything out of range (including NaN and infinity) should return
 0x80000000u.
 Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while
 Max ops: 30
 Rating: 4
 */
int floatFloat2Int(unsigned uf) {
    int exp_mask = 0x7f800000;
    int frac_mask = 0x7fffff;
    int exp = (uf & exp_mask)&gt;&gt;23;
    int frac = uf & frac_mask;
    int signal = uf&gt;&gt;31&1;
    int bias;
    int ans;
    if (exp &lt; 127) {
        return 0;
    } else if (exp == 255 || exp &gt; 127+31) {
        return 0x80000000;
    } else {
        if (exp==127+31){
            if (frac==0 && signal == 1) {
                return 0x80000000;
            } else {
                return 0x80000000;
            }
        } else {
            bias = exp-127;
            if (bias &gt;= 23) {
                ans = (1&lt;&lt;bias) + (1&lt;&lt;bias&gt;&gt;23)*frac;
            } else {
                ans = 1&lt;&lt;bias;
            }
            return signal ? -ans:ans;
        }
    }
}
/*
 * floatPower2 - Return bit-level equivalent of the expression 2.0^x
 (2.0 raised to the power x) for any 32-bit integer x.
 *
 The unsigned value that is returned should have the identical bit
 representation as the single-precision floating-point number 2.0^x.
 If the result is too small to be represented as a denorm, return
 0. If too large, return +INF.
 *
 Legal ops: Any integer/unsigned operations incl. ||, &&. Also if, while
 Max ops: 30
 Rating: 4
 */
unsigned floatPower2(int x) {
    int frac, exp;
    if (x &lt; -149) return 0;
    else if (x &gt;= -149 && x &lt;= -127) {
        frac = x+149;
        return 1 &lt;&lt; frac;
    } else if (x&lt;128) {
        exp = x+127;
        return exp &lt;&lt; 23;
    } else {
        return 255 &lt;&lt; 23;
    }
}</code></pre><p>我自己的做的时候 <code>howManyBits</code> 不知道怎么做,上网查的答案</p><p>其他的题目也都不是特别困难,看一下位运算应该也可以看懂</p><h2 id="h2-3">编译运行</h2><pre><code class="language-bash">make
# 编译会有一个警告,忽略即可
# 检查正确性,如果没有输出则说明所有函数实现符合要求,否则需要修改
./dlc bits.c
./btest</code></pre><pre><code class="language-bash">root@da1811a84ddc:~/csapplabs/01Data Lab/datalab-handout# ./dlc bits.c
root@da1811a84ddc:~/csapplabs/01Data Lab/datalab-handout# ./btest
Score   Rating  Errors  Function
 1      1       0       bitXor
 1      1       0       tmin
 1      1       0       isTmax
 2      2       0       allOddBits
 2      2       0       negate
 3      3       0       isAsciiDigit
 3      3       0       conditional
 3      3       0       isLessOrEqual
 4      4       0       logicalNeg
 4      4       0       howManyBits
 4      4       0       floatScale2
 4      4       0       floatFloat2Int
ERROR: Test floatPower2 failed.
  Timed out after 10 secs (probably infinite loop)
Total points: 32/36</code></pre><p>最后的 <code>floatPower2</code> 超时是因为测试案例太多了,修改btest.c中的TIMEOUT_LIMIT宏,重新编译后通过</p><pre><code class="language-c">// btest.c
#define TIMEOUT_LIMIT 20</code></pre><pre><code class="language-bash">root@da1811a84ddc:~/csapplabs/01Data Lab/datalab-handout# ./btest
Score   Rating  Errors  Function
 1      1       0       bitXor
 1      1       0       tmin
 1      1       0       isTmax
 2      2       0       allOddBits
 2      2       0       negate
 3      3       0       isAsciiDigit
 3      3       0       conditional
 3      3       0       isLessOrEqual
 4      4       0       logicalNeg
 4      4       0       howManyBits
 4      4       0       floatScale2
 4      4       0       floatFloat2Int
 4      4       0       floatPower2
Total points: 36/36</code></pre><p>关于浮点数的知识笔者留下的印象也不多了,故特做了一文<a href="https://zhuanlan.zhihu.com/p/580191161?" target="_blank">计算机系统基础：浮点数的表示</a></p></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../md-docs/01-DataLab" >01-DataLab</a></li></ul><ul><li><a href="../../md-docs/02-BombLab" >02-BombLab</a></li></ul><ul><li><a href="../../md-docs/03-AttackLab" >03-AttackLab</a></li></ul><ul><li><a href="../../md-docs/04-BufferLab" >04-BufferLab</a></li></ul><ul><li><a href="../../md-docs/05-ArchLab" >05-ArchLab</a></li></ul><ul><li><a href="../../md-docs/06-ArchY86Lab" >06-ArchY86Lab</a></li></ul><ul><li><a href="../../md-docs/07-CacheLab" >07-CacheLab</a></li></ul><ul><li><a href="../../md-docs/08-PerfLab" >08-PerfLab</a></li></ul><ul><li><a href="../../md-docs/09-ShellLab" >09-ShellLab</a></li></ul><ul><li><a href="../../md-docs/10-MallocLab" >10-MallocLab</a></li></ul><ul><li><a href="../../md-docs/11-ProxyLab" >11-ProxyLab</a></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../md-docs/README","../../md-docs/02-BombLab","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/prism.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/check_box.js"></script>
</body>

</html>