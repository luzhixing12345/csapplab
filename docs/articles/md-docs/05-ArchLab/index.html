<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/prism.css /><link rel='stylesheet' href=../../../css/index.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/csapplab.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">ArchLab</a><ul><li><a href="#h2-1">处理器体系结构</a></li></ul><ul><li><a href="#h2-2">Y86 指令集体系结构</a></li></ul><ul><li><a href="#h2-3">Y86-64 指令集</a></li></ul><ul><li><a href="#h2-4">Y86-64 程序</a></li></ul><ul><li><a href="#h2-5">数字电路和逻辑门</a></li></ul><ul><li><a href="#h2-6">Y86-64 的顺序实现</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">ArchLab</h1><p>05 06 的实验很接近, 本节主要介绍有关体系结构的基础知识以及 Y86-64 的设计, 所有的实验解答都一起放在下一节 06-ArchY86Lab 中</p><p>关于体系结构的实验可能做的人不会很多, 指令集/处理器对于相当一部分人来说都是很陌生的, 直接上手 Y86 汇编应该是相当吃力的, 因此建议读者先阅读一下第四章处理器体系结构, 再结合实验所提供的文档继续完成实验</p><p>笔者也对书中内容和文档资料做了一些总结</p><h2 id="h2-1">处理器体系结构</h2><p>我们知道处理器必须执行一系列指令, 每条指令执行某个简单操作, 例如两个数相加. 指令被编码为由一个或多个字节序列组成的二进制格式. 一个处理器支持的指令和指令的字节集编码称为它的指令集体系结构(Instruction-Set Architecture ISA).</p><p>不同的处理器家族, 例如 X86-64, ARM 都有不同的 ISA. 一个程序编译成在一种机器上运行就不能再另一种机器上运行.</p><p>另外同一个家族里也有很多不同型号的处理器, 虽然每个厂商制造的处理器性能和复杂性不断提高, 但是不同型号在 ISA 级别上都保持着兼容. 一些常见的处理器家族,例如 x86-64 的处理器分别由多个厂商提供, <b>因此 ISA 在编译器编写者和处理器设计人员之间提供了一个概念抽象层</b>, 编译器编写者只需要知道允许哪些指令以及他们是如何编码的; 而处理器设计者必须制造出执行这些指令的处理器.</p><h2 id="h2-2">Y86 指令集体系结构</h2><p>本章首先定义一个简单的指令集,作为我们处理器实现的运行示例.因为受x86-64指令集的启发,它被俗称为"x86",所以我们称我们的指令集为"Y86-64"指令集.与x86-64 相比,Y86-64指令集的数据类型、指令和寻址方式都要少一些.它的字节级编码也比较简单,机器代码没有相应的x86-64 代码紧凑,不过设计它的CPU译码逻辑也要简单一些.虽然Y86-64 指令集很简单,它仍然足够完整,能让我们写一些处理整数的程序.设计实现 Y86-64的处理器要求我们解决许多处理器设计者同样会面对的问题.</p><p>想要定义一个指令集体系结构(例如 Y86-64), 那么需要<b>定义各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理.</b></p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230607002448.png" alt="20230607002448"></p><p>如上图所示, Y86 的程序可见状态包括寄存器, 条件码, 内存, 程序状态. Y86 的程序可以访问和修改程序寄存器, 条件码, 状态码, 来指明程序是否正常运行, 或者发生了一些特殊事件</p><ul><li>Y86 具有类似 x86-64 有 15 个程序寄存器(省略了 r15). 每一个寄存器存储一个 64 位的字. <b>除了寄存器 rsp 被入栈/出栈/调用/返回指令作为栈指针外, 寄存器没有固定的含义或固定值</b></li></ul><ul><li>Y86 有 3 个一位的条件码 ZF SF OF , 他们保存着最近的算术或逻辑指令所造成影响的有关信息, 程序计数器 PC 存放当前正在执行指令的地址</li></ul><ul><li>内存从概念上来说是一个很大的字节数组, 保存着程序和数据. 程序状态码 stat 表明程序执行的总体状态, 它会指示正常运行还是出现了某种异常.<p>stat 的状态在 Y86-64 架构中一共有4种, 如下所示</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230713102409.png" alt="20230713102409"></p><blockquote><p>对于 Y86-64 当遇到这些异常的时候简单的让处理器停止执行指令, 在更完整的设计中,处理器通常会调用一个异常处理程序(exception handler),这个过程被指定用来处理遇到的某种类型的异常.异常处理程序可以被配置成不同的结果,例如中止程序或者调用一个用户自定义的信号处理程序(signal handler).</p></blockquote></li></ul><h2 id="h2-3">Y86-64 指令集</h2><p>Y86-64 指令集基本上是 x86-64 的一个子集, 如下所示. 其中<b>指令为 1-10 字节不定长编码</b>, 仅支持对于整数的操作, 下面来详细介绍一下</p><blockquote><p>这里希望读者已经对第三章x86汇编有所了解, 不然读起来会有些吃力</p></blockquote><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230629132220.png" alt="20230629132220"></p><ul><li>halt(停止指令执行, 类似x86的hlt), nop 空指令, call ret pushq popq 和 x86 中使用方式相同</li></ul><ul><li>x86 中的 movq 在 Y86 当中被拆分成了4条指令 <code>SDmovq</code>, 其中 S 代表源类型, 可以是立即数(i), 寄存器(r), 内存(m). D 代表目的类型, 可以是寄存器(r)和内存(m).<p>同x86-64一样, Y86 不支持从一个内存地址直接传送到另一个内存地址, 也不允许将立即数传送到内存, 所以合法的movq指令剩下 3<i>2-2 = 4种, 分别是 </i><i>irmovq, rrmovq, mrmovq, rmmovq</i>*</p><p>同时在内存传送指令的内存引用方式<b>只支持基地址(rb)+偏移量(Imm)的方式</b>. 例如 <code>rmmovq rA, D(rB)</code>. 不支持像 x86-64 一样更复杂的第二变址寄存器(ri)和寄存器值的伸缩(scale), 例如 <code>Imm(%rb, %ri, s)</code>, 这是不支持的</p><p>上图中 irmovq 的 F 表示一个不访问任何寄存器, 即空占位(因为Y86中没有r15(0xf))</p></li></ul><ul><li>OPq 为整数操作指令, Y86 中仅支持操作整数. OPq 有4种分别是 addq, subq, andq, xorq, 它们由图中 fn(依次顺序对应0-3)来区分, 在计算结束后还会设置 ZF SF OF 三个条件码<blockquote><p>x86 还支持对内存数据进行操作, 不过Y86不支持</p></blockquote></li></ul><ul><li>jXX 为跳转指令有7种, 由fn区分. jmp jle jl je jne jge jg. 同x86-64的分支条件, 根据条件码和指令类型进行跳转</li></ul><ul><li>cmovxx 为条件传送指令有6种, 由fn区分, cmovle, cmovl, cmove, cmovne, cmovge, cmovg</li></ul><blockquote><p>下图为 x86 支持的内存传送指令, Y86 仅支持基地址+偏移量的方式</p></blockquote><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230629140915.png" alt="20230629140915"></p><p>上面提到了 4 种整数操作指令, 7 种跳转指令和 6 种条件传送指令的 fn 对应值如下图所示</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230629150010.png" alt="20230629150010"></p><p>跳转的条件码判断如下图所示, 和 x86 完全相同</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230629132011.png" alt="20230629132011"></p><p>寄存器数字编号与名称对应值如下图所示, F 代表无寄存器</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230629150035.png" alt="20230629150035"></p><p>最后我们整体观察一下 Y86 指令集特点: 0 字节用于区分指令类型, 有的指令需要附加的寄存器指示符字节, 有的还需要操作数.这些寄存器字段称为rA和rB.从指令的汇编代码表示中可以看到,根据指令类型,指令可以指定用于数据源和目的的寄存器,或是用于地址计算的基址寄存器.没有寄存器操作数的指令,例如分支指令和call 指令,就没有寄存器指示符字节.那些只需要一个寄存器操作数的指令(irmovq、pushq和 popq)将另一个寄存器指示符设为0xF.这种约定在我们的处理器实现中非常有用.</p><p>有些指令需要附加一个 4 字节的常数字, 作为立即数数据/地址偏移量/目的地址, <b>值得注意的是作为目的地址的时候是一个绝对地址</b>, 而不是像 IA32 一样使用 PC 相对地址. 同时对于整数使用了小端序.</p><blockquote><p>例如,用十六进制来表示指令rmmovq %rsp,0x123456789abcd (%rdx)的字节编码.其中rrmmovq的第一个字节为40.源寄存器%rsp应该编码放在rA字段中,而基址寄存器%rdx应该编码放在rB字段中.查表得到寄存器指示符字节 42.最后,偏移量编码放在8字节的常数字中.首先在Ox123456789abcd的前面填充上0变成8个字节,变成字节序列00 012345 67 89 ab cd.写成按字节反序就是cd ab 89 67 45 23 01 00.将它们都连接起来就得到指令的编码 <code>4042cdab896745230100</code></p></blockquote><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230629132220.png" alt="20230629132220"></p><p><b>指令集的一个重要性质就是字节编码必须有唯一的解释</b>.任意一个字节序列要么是一个唯一的指令序列的编码,要么就不是一个合法的字节序列.Y86-64就具有这个性质,因为每条指令的第一个字节有唯一的代码和功能组合,给定这个字节,我们就可以决定所有其他附加字节的长度和含义.</p><p>这个性质保证了处理器可以无二义性地执行目标代码程序.即使代码嵌入在程序的其他字节中,只要从序列的第一个字节开始处理,我们仍然可以很容易地确定指令序列.反过来说,如果不知道一段代码序列的起始位置,我们就不能准确地确定怎样将序列划分成单独的指令.对于试图直接从目标代码字节序列中抽取出机器级程序的反汇编程序和其他一些工具来说,这就带来了问题.</p><p>同x86-64中的指令编码相比,Y86-64的编码简单得多,但是没那么紧凑.在所有的Y86-64指令中,寄存器字段的位置都是固定的,而在不同的x86-64指令中,它们的位置是不一样的.x86-64可以将常数值编码成 1、2、4或8个字节,<b>而Y86-64总是将常数值编码成8个字节</b>.</p><blockquote><p>另外关于 RISC CISC 指令集的讨论, 书中也给出了两段旁注, 非常值得一读.</p><p>20世纪80年代,计算机体系结构领域里关于RISC指令集和CISC 指令集优缺点的争论十分激烈.RISC的支持者声称在给定硬件数量的情况下,通过结合简约式指令集设计、高级编译器技术和流水线化的处理器实现,他们能够得到更强的计算能力.而CISC的拥趸反驳说要完成一个给定的任务只需要用较少的CISC指令,所以他们的机器能够获得更高的总体性能.</p><p>然而事实证明无论是单纯的RISC还是单纯的CISC都不如结合两者思想精华的设计.RISC机器发展进化的过程中,引入了更多的指令,而许多这样的指令都需要执行多个周期.今天的RISC机器的指令表中有几百条指令,几乎与"精简指令集机器"的名称不相符了.那种将实现细节暴露给机器级程序的思想已经被证明是目光短浅的.随着使用更加高级硬件结构的新处理器模型的开发,许多实现细节已经变得很落后了,但它们仍然是指令集的一部分.不过,作为RISC设计的核心的指令集仍然是非常适合在流水线化的机器上执行的.</p><p>比较新的CISC机器也利用了高性能流水线结构.它们读取CISC指令,并动态地翻译成比较简单的、像 RISC那样的操作的序列.例如,一条将寄存器和内存相加的指令被翻译成三个操作:一个是读原始的内存值,一个是执行加法运算,第三就是将和写回内存.由于动态翻译通常可以在实际指令执行前进行,处理器仍然可以保持很高的执行速率.</p></blockquote><h2 id="h2-4">Y86-64 程序</h2><p>书中给出了一个比较基础的汇编程序示例, 对照左侧 x86-64 指令集, 右侧也都是前文介绍过的汇编指令. y86-64 采用了和x86-64相同的参数传递和寄存器保存方法</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230630095503.png" alt="20230630095503"></p><p>观察上面的程序, 可以注意到一些不同之处</p><ul><li>Y86-64 需要先将常数加载到寄存器, 因为在算数指令不能使用立即数</li></ul><ul><li>从内存中读取一个数值并于一个寄存器值相加(sum+=*start)在 Y86-64 中需要两条指令(8,9), 而 x86-64 只需要一条 addq(5)</li></ul><ul><li>Y86-64 中11行使用了 subq 实现 -1 之外还设置了条件码, 可以直接进行后续的 jne 判断而不需要像 x86 一样通过 testq 判断</li></ul><p>下面是一段比较简单但是完整的 y86-64 汇编代码, 你可以在 <a href="https://github.com/luzhixing12345/csapplab/blob/main/05_arch_lab/archlab-handout/sim/y86-code/asum.ys" target="_blank">y86-code/asum.ys</a> 中找到这段代码. 这段代码就是利用上面的 sum 函数, 对于 array 数组中的元素求和</p><pre><code class="language-y86asm"># Execution begins at address 0 
    .pos 0
    irmovq stack, %rsp      # Set up stack pointer
    call main       # Execute main program
    halt            # Terminate program
# Array of 4 elements
    .align 8
array:
    .quad 0x000d000d000d
    .quad 0x00c000c000c0
    .quad 0x0b000b000b00
    .quad 0xa000a000a000
main:
    irmovq array,%rdi
    irmovq $4,%rsi
    call sum        # sum(array, 4)
    ret
# long sum(long *start, long count)
# start in %rdi, count in %rsi
sum:
    irmovq $8,%r8        # Constant 8
    irmovq $1,%r9        # Constant 1
    xorq %rax,%rax       # sum = 0
    andq %rsi,%rsi       # Set CC
    jmp     test         # Goto test
loop:
    mrmovq (%rdi),%r10   # Get *start
    addq %r10,%rax       # Add to sum
    addq %r8,%rdi        # start++
    subq %r9,%rsi        # count--.  Set CC
test:
    jne    loop          # Stop when 0
    ret                  # Return
# Stack starts here and grows to lower addresses
    .pos 0x200
stack:</code></pre><p>除了我们熟悉的y86-64指令集, 汇编中还出现了#开头的注释, <code>.</code> 开头的汇编伪指令以及段的声明, 这部分与 x86 汇编类似, 简单解释一下.</p><ul><li><code>.pos</code> 指的是从当前地址开始生成代码, 比如开头的 .pos 0 和结尾的 .pos 0x200</li></ul><ul><li><code>.align</code> 用于对齐</li></ul><ul><li><code>.quad</code> 用于定义一个四字(8字节)</li></ul><ul><li>声明不分前后, 比如 main stack 等段名都定义在后文, 最后生成机器码时会做一个名称到地址的翻译</li></ul><p>可以利用 yas 汇编器先将 y86-64 的汇编代码转换为对应的机器码</p><pre><code class="language-bash"># in directory y86-code
$ ../misc/yas asum.ys</code></pre><p>得到 <a href="https://github.com/luzhixing12345/csapplab/blob/main/05_arch_lab/archlab-handout/sim/y86-code/asum.yo" target="_blank">asum.yo</a> 文件内容如下, 可以看到对应的汇编指令按照前文提到的指令编码方式被整齐的转换为机器码</p><pre><code class="language-y86asm">                            | # Execution begins at address 0
0x000:                      |   .pos 0
0x000: 30f40002000000000000 |   irmovq stack, %rsp      # Set up stack pointer
0x00a: 803800000000000000   |   call main       # Execute main program
0x013: 00                   |   halt            # Terminate program
                            |
                            | # Array of 4 elements
0x018:                      |   .align 8
0x018: 0d000d000d000000     | array:    .quad 0x000d000d000d
0x020: c000c000c0000000     |   .quad 0x00c000c000c0
0x028: 000b000b000b0000     |   .quad 0x0b000b000b00
0x030: 00a000a000a00000     |   .quad 0xa000a000a000
                            |
0x038: 30f71800000000000000 | main: irmovq array,%rdi
0x042: 30f60400000000000000 |   irmovq $4,%rsi
0x04c: 805600000000000000   |   call sum        # sum(array, 4)
0x055: 90                   |   ret
                            |
                            | # long sum(long *start, long count)
                            | # start in %rdi, count in %rsi
0x056: 30f80800000000000000 | sum:  irmovq $8,%r8        # Constant 8
0x060: 30f90100000000000000 |   irmovq $1,%r9        # Constant 1
0x06a: 6300                 |   xorq %rax,%rax       # sum = 0
0x06c: 6266                 |   andq %rsi,%rsi       # Set CC
0x06e: 708700000000000000   |   jmp     test         # Goto test
0x077: 50a70000000000000000 | loop: mrmovq (%rdi),%r10   # Get *start
0x081: 60a0                 |   addq %r10,%rax       # Add to sum
0x083: 6087                 |   addq %r8,%rdi        # start++
0x085: 6196                 |   subq %r9,%rsi        # count--.  Set CC
0x087: 747700000000000000   | test: jne    loop          # Stop when 0
0x090: 90                   |   ret                  # Return
                            |
                            | # Stack starts here and grows to lower addresses
0x200:                      |   .pos 0x200
0x200:                      | stack:</code></pre><p>最后使用 yis 执行结果如下, 可以观察到 rax 寄存器的值变为定义的四个数组元素的和 <code>0xabcdabcdabcd</code>. 同时由于在汇编中使用了两次call(call main, call sum), 栈rsp指针为 0x200, 所以下面的两个内存地址(0x01f0, 0x01f8) 的值也被修改了, 不过好在 asum.yo 中代码段可以看到最后的位置是 <code>0x090: 90</code>, 所以数值的入栈和出栈没有影响到代码段</p><pre><code class="language-bash">$ ../misc/yis  asum.yo
Stopped in 34 steps at PC = 0x13.  Status 'HLT', CC Z=1 S=0 O=0
Changes to registers:
%rax:   0x0000000000000000      0x0000abcdabcdabcd
%rsp:   0x0000000000000000      0x0000000000000200
%rdi:   0x0000000000000000      0x0000000000000038
%r8:    0x0000000000000000      0x0000000000000008
%r9:    0x0000000000000000      0x0000000000000001
%r10:   0x0000000000000000      0x0000a000a000a000

Changes to memory:
0x01f0: 0x0000000000000000      0x0000000000000055
0x01f8: 0x0000000000000000      0x0000000000000013</code></pre><h2 id="h2-5">数字电路和逻辑门</h2><p>接下来书中又介绍了关于数字逻辑电路的相关知识, 首先是最基础的三个布尔函数 AND OR NOT, 对应的表示HCL符号为 && || !</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230630222854.png" alt="20230630222854"></p><p>利用这三个基本的逻辑门就可以构建很多复杂的组合电路, 这些电路的网络有一些限制</p><ol start="1"><li>每个逻辑门的输入必须连接到 [一个系统输入] | [某个存储器单元的输出] | [某个逻辑门的输出]</li></ol><ol start="2"><li>两个或多个逻辑门的输出不能连在一起(会导致信号矛盾, 不合法的电压/电路故障)</li></ol><ol start="3"><li>无环(会导致计算歧义)</li></ol><p>下面来看一个简单的例子, 下图的组合电路的效果是只有a,b同为1/0的时候结果才为1, 想要写出它的HCL语言可以从右向左看, 首先是一个OR, 所以是 <code>bool x = ? || ?</code>, 上下再分别观察拆分为 <code>bool x = (a&&b) || (!a && !b)</code></p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230630222609.png" alt="20230630222609"></p><p>再看一个小例子, 下图是一个很经典的组合电路, 也被称为多路复用器(MUX), 其特点为当 s=1 时结果为 a 的值, 当 s=0 时结果为 b 的值, 其 HCL 表示为 <code>bool x = (s&&a) || (!s&&b)</code></p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230630222631.png" alt="20230630222631"></p><p>同时需要注意的是 HCL 表达式和 C 表达式也有一些区别</p><ol start="1"><li>因为组合电路是由一系列的逻辑门组成,它的属性是输出会持续地响应输入的变化.如果电路的输人变化了,在一定的延迟之后,输出也会相应地变化.相比之下,C表达式只会在程序执行过程中被遇到时才进行求值.</li></ol><ol start="2"><li>C的逻辑表达式允许参数是任意整数,0表示FALSE,其他任何值都表示TRUE.而逻辑门只对位值0和1进行操作.</li></ol><ol start="3"><li>C的逻辑表达式有个属性就是它们可能只被部分求值.如果一个AND或OR操作的结果只用对第一个参数求值就能确定,那么就不会对第二个参数求值了.而组合逻辑没有部分求值这条规则,逻辑门只是简单地响应输入的变化.</li></ol><p>通过将位级电路进行组合可以得到更大的网, 处理器设计经常会包含很多字, 我们可以做一个字级别的抽象, 如下图所示, 只要AB的每一位都相同我们就可以说 A == B. 这里的字级抽象即将线所代表的意义从比特上升为了(8*)含义上的字</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230630231628.png" alt="20230630231628"></p><p>于此同时处理器中也会经常使用多路复用器, 下图是前文提到过的MUX, 其效果是当 s=1 时输出A, 否则输出B. 对应的字级抽象如右侧所示.</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230630232435.png" alt="20230630232435"></p><p>但是这里的 HCL 表达式会有一点点奇怪, 这里简单解释一下. 多路复用函数采用情况表达式来描述, 表达式的通用格式就是 <code>[select: expr; ...]</code>. <b>这里不要求每一个表达式都互斥, 且表达式的选择是顺序求值的, 第一个求值为1 的情况会被选中</b>, 有点类似 <code>if elif elif ... else</code></p><pre><code class="language-HCL">word Out = [
    s: A;
    1: B;
]</code></pre><p>所以分析一下上面的HCL表达式, 当 s=0 的时候第一项没有匹配到, 所以选择了第二项B. 当s=1的时候匹配到了所以选择A, 和预期相同.</p><p>需要注意的是表达式的选择是顺序求值的, 所以通常最后一个标记为1, 相当于最后一个 else</p><p>我们再看一个简单的四路复用器, 其中 s0 s1 一起控制了输出结果</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230630233233.png" alt="20230630233233"></p><p>一般来说可能会写出如下的 HCL</p><pre><code class="language-HCL">word Out4 = [
    !s1 && !s0 : A; # 00
    !s1 &&  s0 : B; # 01
     s1 && !s0 : C; # 10
     s1 &&  s0 : D; # 11
]</code></pre><p>但考虑到顺序判断的行为, 也可以写作如下的方式. 当然从阅读的角度来说笔者更倾向于前者</p><pre><code class="language-HCL">word Out4 = [
    !s1 && !s0 : A; # 00
    !s1        : B; # 01
    !s0        : C; # 10
    1          : D; # 11
]</code></pre><p>ALU(算数逻辑单元)是一种重要的组合电路, 具体的实现比较复杂, 其大致功能效果如下所示, 即对于不同的输入 s ALU 可以执行不同的运算</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230701121823.png" alt="20230701121823"></p><blockquote><p>这里的是 X-Y 对应 Y86-64 中 subq 的顺序</p></blockquote><p>在处理器设计中,很多时候都需要将一个信号与许多可能匹配的信号做比较,以此来检测正在处理的某个指令代码是否属于某一类指令代码.比如下面这个例子中 <b>code 是一个 2-bits 的信号</b>, 为了使用MUX控制ABCD的选择需要将其拆分为 s0, s1 两个信号</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230701122836.png" alt="20230701122836"></p><p>因此可以分别判断 <code>s1s0</code> 两位的值, 即2和3的高位为1, 1和3低位为1, 可以写作如下的方式</p><pre><code class="language-UNKNOWN">bool s1 = code == 2 || code == 3;
bool s0 = code == 1 || code == 3;</code></pre><p>当然可以更简化一些写成集合的形式, 这两种方式也是等价的</p><pre><code class="language-UNKNOWN">bool s1 = code in {2,3};
bool s2 = code in {1,3};</code></pre><hr><p>组合电路从本质上讲,<b>不存储任何信息.相反,它们只是简单地响应输人信号,产生等于输入的某个函数的输出</b>.为了产生时序电路( sequential circuit),也就是有状态并且在这个状态上进行计算的系统,我们必须引入按位存储信息的设备.存储设备都是由同一个时钟控制的,时钟是一个周期性信号,决定什么时候要把新值加载到设备中.</p><p>在说到硬件和机器级编程时,"寄存器"这个词是两个有细微差别的事情.</p><ul><li>在硬件中,寄存器直接将它的输入和输出线连接到电路的其他部分.</li></ul><ul><li>在机器级编程中,寄存器代表的是CPU中为数不多的可寻址的字,这里的地址是寄存器ID.这些字通常都存在寄存器文件中,虽然我们会看到硬件有时可以直接将一个字从一个指令传送到另一个指令,以避免先写寄存器文件再读出来的延迟.</li></ul><p>需要避免歧义时,我们会分别称呼这两类寄存器为"硬件寄存器"和"程序寄存器". 下图展示了一个硬件寄存器的工作模式, 大多数时候寄存器保持在稳定状态 x, 输出等于它的当前状态x. <b>这时候虽然产生了一个新的寄存器输入 y 但只要始终是地点为的寄存器的输出就仍然不变</b></p><p>当始终变为高电位的时候输入信号 y 就加载到寄存器中成为下一个状态 y, 直到下一个时钟上升沿这个状态 y 也一直是寄存器的新输出</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230713104457.png" alt="20230713104457"></p><p>下图展示了一个典型的寄存器文件</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230713105629.png" alt="20230713105629"></p><p>寄存器文件有两个读端口(A和B),还有一个写端口(W).这样一个多端口随机访问存储器允许同时进行多个读和写操作.</p><p>图中所示的寄存器文件中,电路可以读两个程序寄存器的值,同时更新第三个寄存器的状态.</p><p>每个端口都有一个地址输人,表明该选择哪个程序寄存器,另外还有一个数据输出或对应该程序寄存器的输人值.地址是用上文中编码表示的寄存器标识符.两个读端口有地址输入srcA和 srcB("source A"和"source B"的缩写)和数据输出valA和 valB("value A"和"value B"的缩写).写端口有地址输人dstw("destination W"的缩写),以及数据输人valw("value W"的缩写).</p><p>在我们的实现中,从寄存器文件读数据就好像它是一个以地址为输人、数据为输出的一个组合逻辑块.当srcA或srcB被设成某个寄存器ID时,在一段延迟之后,存储在相应程序寄存器的值就会出现在valA或valB上.</p><blockquote><p>例如,将srcA设为3,就会读出程序寄存器%rbx的值,然后这个值就会出现在输出valA 上.</p><p>如果读写的寄存器相同, 解决办法是前半个周期写,后半个周期读</p></blockquote><h2 id="h2-6">Y86-64 的顺序实现</h2><p>通常,处理一条指令包括很多操作.将它们组织成某个特殊的阶段序列,即使指令的动作差异很大,但所有的指令都遵循统一的序列.每一步的具体处理取决于正在执行的指令.创建这样一个框架,我们就能够设计一个充分利用硬件的处理器.下面是关于各个阶段以及各阶段内执行操作的简略描述:</p><ol start="1"><li><b>取址(fetch)</b>:取指阶段从内存读取指令字节,地址为程序计数器(PC)的值.从指令中抽取出指令指示符字节的两个四位部分,称为icode(指令代码)和ifun(指令功能). 取出指令后分析指令属于哪一种类型, 并进行解析</li></ol><ol start="2"><li><b>译码(decode)</b>:译码阶段从寄存器文件读入最多两个操作数,得到值valA和/或valB.通常,它读人指令rA和 rB字段指明的寄存器</li></ol><ol start="3"><li><b>执行( execute)</b>;在执行阶段,算术/逻辑单元(ALU)要么执行指令指明的操作(根据ifun的值)完成对应的操作, 可能是修改栈指针, 设置条件码, 更新寄存器, 选择分支等等</li></ol><ol start="4"><li><b>访存(memory)</b>:访存阶段可以将数据写入内存,或者从内存读出数据.读出的值为valM.</li></ol><ol start="5"><li><b>写回( write back)</b>:写回阶段最多可以写两个结果到寄存器文件.</li></ol><ol start="6"><li><b>更新PC(PC update)</b>:将PC设置成下一条指令的地址.</li></ol></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../md-docs/01-DataLab" >01-DataLab</a></li></ul><ul><li><a href="../../md-docs/02-BombLab" >02-BombLab</a></li></ul><ul><li><a href="../../md-docs/03-AttackLab" >03-AttackLab</a></li></ul><ul><li><a href="../../md-docs/04-BufferLab" >04-BufferLab</a></li></ul><ul><li><a href="../../md-docs/05-ArchLab" >05-ArchLab</a></li></ul><ul><li><a href="../../md-docs/06-ArchY86Lab" >06-ArchY86Lab</a></li></ul><ul><li><a href="../../md-docs/07-CacheLab" >07-CacheLab</a></li></ul><ul><li><a href="../../md-docs/08-PerfLab" >08-PerfLab</a></li></ul><ul><li><a href="../../md-docs/09-ShellLab" >09-ShellLab</a></li></ul><ul><li><a href="../../md-docs/10-MallocLab" >10-MallocLab</a></li></ul><ul><li><a href="../../md-docs/11-ProxyLab" >11-ProxyLab</a></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../md-docs/04-BufferLab","../../md-docs/06-ArchY86Lab","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/prism.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/check_box.js"></script>
</body>

</html>