<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/prism.css /><link rel='stylesheet' href=../../../css/index.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/csapplab.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">ArchLab</a><ul><li><a href="#h2-1">前言</a></li></ul><ul><li><a href="#h2-2">PartA</a><ul><li><a href="#h3-3">sum.ys</a></li></ul><ul><li><a href="#h3-4">rsum.ys</a></li></ul></li></ul><ul><li><a href="#h2-5">PartB</a></li></ul><ul><li><a href="#h2-6">参考</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">ArchLab</h1><p>本节来处理</p><h2 id="h2-1">前言</h2><p>在 <code>make</code> 构建的时候会出现一些问题 ,比如 flex bison 未找到 tcl 库没找到这种, <code>.usr/bin/ld: cannot find -lfl</code> 等,运行如下指令安装即可</p><pre><code class="language-bash">sudo apt install tcl tcl-dev tk tk-dev
sudo apt install flex bison</code></pre><p>编译还可能会遇到其他问题, 比如 ld 的时候multi define, 这个主要是因为弱符号强符号的问题, gcc-10 之后的默认选项变成了 -fcommon 所以如果你是 gcc-10 及更高版本会报错, 参考<a href="https://stackoverflow.com/questions/63152352/fail-to-compile-the-y86-simulatur-csapp" target="_blank">fail to compile the y86 simulatur csapp</a> 要么将所有 Makefile 里面的 CFLAGS LCFLAGS 加上 -fcommon</p><p>不过我建议下一个低版本的 gcc-9 然后切为默认, 读者可参考<a href="https://luzhixing12345.github.io/2023/03/14/环境配置/gcc版本切换/" target="_blank">gcc版本切换</a>, 再编译就没问题了</p><h2 id="h2-2">PartA</h2><p>第一部分内容在 sim/misc 下完成</p><h3 id="h3-3">sum.ys</h3><p>第一个任务的要求是编写 Y86-64 的汇编完成 sum_list 函数, 该函数的作用是对链表的值求和, C 代码如下</p><pre><code class="language-c">typedef struct ELE {
    long val;
    struct ELE *next;
} * list_ptr;

/* sum_list - Sum the elements of a linked list */
long sum_list(list_ptr ls) {
    long val = 0;
    while (ls) {
        val += ls-&gt;val;
        ls = ls-&gt;next;
    }
    return val;
}</code></pre><p>我们新建一个文件: misc/sum.ys</p><pre><code class="language-x86asm"># Execution begins at address 0
        .pos 0
        irmovq stack, %rsp      # Set up stack pointer
        call main               # Execute main program
        halt                    # Terminate program
# Sample linked list
        .align 8
ele1:
        .quad 0x00a
        .quad ele2
ele2:
        .quad 0x0b0
        .quad ele3
ele3:
        .quad 0xc00
        .quad 0
main:
        irmovq ele1,%rdi
        call sum_list
        ret
# long sum_list(list_ptr ls)
# start in %rdi
sum_list:
        irmovq $0, %rax
        jmp test
loop:
        mrmovq (%rdi), %rsi
        addq %rsi, %rax
        mrmovq 8(%rdi), %rdi
test:
        andq %rdi, %rdi
        jne loop
        ret
# Stack starts here and grows to lower addresses
        .pos 0x200
stack:
</code></pre><p>利用编译好的 yas 将 sum.ys 翻译为字节码 sum.yo, 再利用 yis 执行, 最后观察到结果 %rax = 0xcba = 0x00a + 0x0b0 + 0xc00, 刚好是三个结构体的value的和,说明正确</p><pre><code class="language-bash">(base) kamilu@LZX:~/csapplab/05_arch_lab/sim/misc$ ./yas sum.ys
(base) kamilu@LZX:~/csapplab/05_arch_lab/sim/misc$ ./yis sum.yo
Stopped in 26 steps at PC = 0x13.  Status &#x27;HLT&#x27;, CC Z=1 S=0 O=0
Changes to registers:
%rax:   0x0000000000000000      0x0000000000000cba
%rsp:   0x0000000000000000      0x0000000000000200
%rsi:   0x0000000000000000      0x0000000000000c00

Changes to memory:
0x01f0: 0x0000000000000000      0x000000000000005b
0x01f8: 0x0000000000000000      0x0000000000000013</code></pre><blockquote><p>汇编代码结尾需要有一行换行, 不然会yas的时候产生警告: <code>Missing end-of-line on final line</code></p></blockquote><h3 id="h3-4">rsum.ys</h3><p>第二个任务是实现递归调用</p><pre><code class="language-c">/* rsum_list - Recursive version of sum_list */
long rsum_list(list_ptr ls) {
    if (!ls)
        return 0;
    else {
        long val = ls-&gt;val;
        long rest = rsum_list(ls-&gt;next);
        return val + rest;
    }
}</code></pre><pre><code class="language-x86asm"># Execution begins at address 0
        .pos 0
        irmovq stack, %rsp      # Set up stack pointer
        call main               # Execute main program
        halt                    # Terminate program
# Sample linked list
        .align 8
ele1:
        .quad 0x00a
        .quad ele2
ele2:
        .quad 0x0b0
        .quad ele3
ele3:
        .quad 0xc00
        .quad 0
main:
        irmovq ele1,%rdi
        call rsum_list
        ret
# long rsum_list(list_ptr ls)
# start in %rdi
rsum_list:
        andq %rdi, %rdi
        je return               # if(!ls)
        mrmovq (%rdi), %rbx     # val = ls-&gt;val
        mrmovq 8(%rdi), %rdi    # ls = ls-&gt;next
        pushq %rbx
        call rsum_list          # rsum_list(ls-&gt;next)
        popq %rbx
        addq %rbx, %rax         # val + rest
        ret
return:
        irmovq $0, %rax
        ret
# Stack starts here and grows to lower addresses
        .pos 0x200
stack:
</code></pre><p>完成递归的思路是先取出 ls-&gt;val 放入 %rbx, 然后利用栈保存值, 先push入栈然后在递归调用的 rsum_list 返回之后从栈中取出 val 求和再返回</p><pre><code class="language-x86asm">        pushq %rbx
        call rsum_list          # rsum_list(ls-&gt;next)
        popq %rbx
        addq %rbx, %rax         # val + rest</code></pre><pre><code class="language-bash">(base) kamilu@LZX:~/csapplab/05_arch_lab/sim/misc$ ./yas rsum.ys
(base) kamilu@LZX:~/csapplab/05_arch_lab/sim/misc$ ./yis rsum.yo
Stopped in 37 steps at PC = 0x13.  Status &#x27;HLT&#x27;, CC Z=0 S=0 O=0
Changes to registers:
%rax:   0x0000000000000000      0x0000000000000cba
%rbx:   0x0000000000000000      0x000000000000000a
%rsp:   0x0000000000000000      0x0000000000000200

Changes to memory:
0x01c0: 0x0000000000000000      0x0000000000000086
0x01c8: 0x0000000000000000      0x0000000000000c00
0x01d0: 0x0000000000000000      0x0000000000000086
0x01d8: 0x0000000000000000      0x00000000000000b0
0x01e0: 0x0000000000000000      0x0000000000000086
0x01e8: 0x0000000000000000      0x000000000000000a
0x01f0: 0x0000000000000000      0x000000000000005b
0x01f8: 0x0000000000000000      0x0000000000000013</code></pre><p>运行可以看到这次修改的内存范围变多了, 因为使用push和call都会入栈修改栈空间附近的内存值, 其中高地址的 <code>0x13</code> <code>0x5b</code> 分别是开始的两次call压栈的返回地址</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230721101114.png" alt="20230721101114"></p><p>然后的 0x00a 是当前结构体的 val 值, 0x86 是 rsum_list 的返回地址</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230721100944.png" alt="20230721100944"></p><p>最后结果 <code>0xcba</code> 也如预期所料</p><p>###</p><pre><code class="language-c">/* copy_block - Copy src to dest and return xor checksum of src */
long copy_block(long *src, long *dest, long len) {
    long result = 0;
    while (len &gt; 0) {
        long val = *src++;
        *dest++ = val;
        result ^= val;
        len--;
    }
    return result;
}</code></pre><pre><code class="language-x86asm"># Execution begins at address 0
        .pos 0
        irmovq stack, %rsp      # Set up stack pointer
        call main               # Execute main program
        halt                    # Terminate program
        .align 8
# Source block
src:
        .quad 0x00a
        .quad 0x0b0
        .quad 0xc00
# Destination block
dest:
        .quad 0x111
        .quad 0x222
        .quad 0x333
main:
        irmovq src, %rdi
        irmovq dest, %rsi
        irmovq $3, %rdx
        call copy_block
        ret
# long copy_block(long *src, long *dest, long len)
# start in %rdi, %rsi, %rdx
copy_block:
        irmovq $0, %rax
        irmovq $8, %r8
        irmovq $1, %r9
        andq %rdx, %rdx
        jne loop
        ret
loop:
        mrmovq (%rdi), %r10
        addq %r8, %rsi
        rmmovq %r10, (%rsi)
        addq %r8, %rdi
        xorq %r10, %rax
        subq %r9, %rdx
        jne loop
        ret
# Stack starts here and grows to lower addresses
        .pos 0x200
stack:
</code></pre><p>由于 Y86-64 的 addq subq 只支持寄存器操作, 所以我们需要使用 r8 r9 把需要使用的常数 <code>long* ++</code> 的 8 和 <code>len--</code> 的 1 保存起来</p><pre><code class="language-bash">(base) kamilu@LZX:~/csapplab/05_arch_lab/sim/misc$ ./yas copy_block.ys
(base) kamilu@LZX:~/csapplab/05_arch_lab/sim/misc$ ./yis copy_block.yo
Stopped in 35 steps at PC = 0x13.  Status &#x27;HLT&#x27;, CC Z=1 S=0 O=0
Changes to registers:
%rax:   0x0000000000000000      0x0000000000000cba
%rsp:   0x0000000000000000      0x0000000000000200
%rsi:   0x0000000000000000      0x0000000000000048
%rdi:   0x0000000000000000      0x0000000000000030
%r8:    0x0000000000000000      0x0000000000000008
%r9:    0x0000000000000000      0x0000000000000001
%r10:   0x0000000000000000      0x0000000000000c00

Changes to memory:
0x0038: 0x0000000000000222      0x000000000000000a
0x0040: 0x0000000000000333      0x00000000000000b0
0x0048: 0x000000000018f730      0x0000000000000c00
0x01f0: 0x0000000000000000      0x000000000000006f
0x01f8: 0x0000000000000000      0x0000000000000013</code></pre><p>结果显示 result 的值是 src 的中的异或结果 <code>0xcba</code>, 并且原先 dest 的地址中 0x38 0x40 0x48 也被修改为了 src 中对应的值</p><h2 id="h2-5">PartB</h2><p>第二部分在 sim/seq 下完成, 在原有指令集中添加一个iaddq指令, 实现立即数+寄存器</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230721134051.png" alt="20230721134051"></p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230721133649.png" alt="20230721133649"></p><table><tr><th>阶段</th><th>iaddq V, rB</th></tr><tr><td style="text-align:center">                取指</td><td style="text-align:center">                icode:ifun ⟵ M1[PC] <br/> rA:rB ⟵ M1[PC+1] <br/> valC ⟵ M8[PC+2] <br/> valP ⟵ PC+10</td></tr><tr><td style="text-align:center">                译码</td><td style="text-align:center">                valB ⟵ R[rB]</td></tr><tr><td style="text-align:center">                执行</td><td style="text-align:center">                valE ⟵ valB + valC</td></tr><tr><td style="text-align:center">                访存</td><td style="text-align:center">                </td></tr><tr><td style="text-align:center">                写回</td><td style="text-align:center">                R[rB] ⟵ valE</td></tr><tr><td style="text-align:center">                更新PC</td><td style="text-align:center">                PC ⟵ valP</td></tr></table><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230721144008.png" alt="20230721144008"></p><h2 id="h2-6">参考</h2><ul><li><a href="https://deconx.cn/docs/system/CSAPP/Lab04-Architecture_Lab" target="_blank">deconx Lab04-Architecture_Lab</a></li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../md-docs/01-DataLab" >01-DataLab</a></li></ul><ul><li><a href="../../md-docs/02-BombLab" >02-BombLab</a></li></ul><ul><li><a href="../../md-docs/03-AttackLab" >03-AttackLab</a></li></ul><ul><li><a href="../../md-docs/04-BufferLab" >04-BufferLab</a></li></ul><ul><li><a href="../../md-docs/05-ArchLab" >05-ArchLab</a></li></ul><ul><li><a href="../../md-docs/06-ArchY86Lab" >06-ArchY86Lab</a></li></ul><ul><li><a href="../../md-docs/07-CacheLab" >07-CacheLab</a></li></ul><ul><li><a href="../../md-docs/08-PerfLab" >08-PerfLab</a></li></ul><ul><li><a href="../../md-docs/09-ShellLab" >09-ShellLab</a></li></ul><ul><li><a href="../../md-docs/10-MallocLab" >10-MallocLab</a></li></ul><ul><li><a href="../../md-docs/11-ProxyLab" >11-ProxyLab</a></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../md-docs/05-ArchLab","../../md-docs/07-CacheLab","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/prism.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/check_box.js"></script>
</body>

</html>