# ArchLab

05 06 的实验是关于体系结构的实验可能做的人不会很多, 指令集/处理器对于相当一部分人来说都是很陌生的, 直接上手 Y86 汇编应该是相当吃力的, 因此建议读者先阅读一下第四章处理器体系结构, 再结合实验所提供的文档继续完成实验

笔者也对书中内容和文档资料做了一些总结

## 前言

在 `make` 构建的时候会出现一些问题 ,比如 flex bison 未找到 tcl 库没找到这种, `.usr/bin/ld: cannot find -lfl` 等,运行如下指令安装即可

```bash
sudo apt install tcl tcl-dev tk tk-dev
sudo apt install flex bison
```

编译还可能会遇到其他问题, 比如 ld 的时候multi define, 这个主要是因为弱符号强符号的问题, gcc-10 之后的默认选项变成了 -fcommon 所以如果你是 gcc-10 及更高版本会报错, 参考[fail to compile the y86 simulatur csapp](https://stackoverflow.com/questions/63152352/fail-to-compile-the-y86-simulatur-csapp) 要么将所有 Makefile 里面的 CFLAGS LCFLAGS 加上 -fcommon

不过我建议下一个低版本的 gcc-9 然后切为默认, 读者可参考[gcc版本切换](https://luzhixing12345.github.io/2023/03/14/环境配置/gcc版本切换/), 再编译就没问题了

## 处理器体系结构

我们知道处理器必须执行一系列指令, 每条指令执行某个简单操作, 例如两个数相加. 指令被编码为由一个或多个字节序列组成的二进制格式. 一个处理器支持的指令和指令的字节集编码称为它的指令集体系结构(Instruction-Set Architecture ISA). 

不同的处理器家族, 例如 X86-64, ARM 都有不同的 ISA. 一个程序编译成在一种机器上运行就不能再另一种机器上运行.

另外同一个家族里也有很多不同型号的处理器, 虽然每个厂商制造的处理器性能和复杂性不断提高, 但是不同型号在 ISA 级别上都保持着兼容. 一些常见的处理器家族,例如 x86-64 的处理器分别由多个厂商提供, **因此 ISA 在编译器编写者和处理器设计人员之间提供了一个概念抽象层**, 编译器编写者只需要知道允许哪些指令以及他们是如何编码的; 而处理器设计者必须制造出执行这些指令的处理器.

## Y86 指令集体系结构

本章首先定义一个简单的指令集，作为我们处理器实现的运行示例。因为受x86-64指令集的启发，它被俗称为“x86”，所以我们称我们的指令集为“Y86-64”指令集。与x86-64 相比，Y86-64指令集的数据类型、指令和寻址方式都要少一些。它的字节级编码也比较简单，机器代码没有相应的x86-64 代码紧凑，不过设计它的CPU译码逻辑也要简单一些。虽然Y86-64 指令集很简单，它仍然足够完整，能让我们写一些处理整数的程序。设计实现 Y86-64的处理器要求我们解决许多处理器设计者同样会面对的问题。

想要定义一个指令集体系结构(例如 Y86-64), 那么需要**定义各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理。**

![20230607002448](https://raw.githubusercontent.com/learner-lu/picbed/master/20230607002448.png)

如上图所示, Y86 的程序可见状态包括寄存器, 条件码, 内存, 程序状态. Y86 的程序可以访问和修改程序寄存器, 条件码, 状态码, 来指明程序是否正常运行, 或者发生了一些特殊事件

- Y86 具有类似 x86-64 有 15 个程序寄存器(省略了 r15). 每一个寄存器存储一个 64 位的字. **除了寄存器 rsp 被入栈/出栈/调用/返回指令作为栈指针外, 寄存器没有固定的含义或固定值**
- Y86 有 3 个一位的条件码 ZF SF OF , 他们保存着最近的算术或逻辑指令所造成影响的有关信息, 程序计数器 PC 存放当前正在执行指令的地址
- 内存从概念上来说是一个很大的字节数组, 保存着程序和数据. 程序状态码 stat 表明程序执行的总体状态, 它会指示正常运行还是出现了某种异常.

## Y86-64 指令集

Y86-64 指令集基本上是 x86-64 的一个子集, 如下所示. 其中**指令为 1-10 字节不定长编码**, 仅支持对于整数的操作, 下面来详细介绍一下

> 这里希望读者已经对第三章x86汇编有所了解, 不然读起来会有些吃力

![20230629132220](https://raw.githubusercontent.com/learner-lu/picbed/master/20230629132220.png)

- halt(停止指令执行, 类似x86的hlt), nop 空指令, call ret pushq popq 和 x86 中使用方式相同
- x86 中的 movq 在 Y86 当中被拆分成了4条指令 `SDmovq`, 其中 S 代表源类型, 可以是立即数(i), 寄存器(r), 内存(m). D 代表目的类型, 可以是寄存器(r)和内存(m).

  同x86-64一样, Y86 不支持从一个内存地址直接传送到另一个内存地址, 也不允许将立即数传送到内存, 所以合法的movq指令剩下 3*2-2 = 4种, 分别是 **irmovq, rrmovq, mrmovq, rmmovq**

  同时在内存传送指令的内存引用方式**只支持基地址(rb)+偏移量(Imm)的方式**. 例如 `rmmovq rA, D(rB)`. 不支持像 x86-64 一样更复杂的第二变址寄存器(ri)和寄存器值的伸缩(scale), 例如 `Imm(%rb, %ri, s)`, 这是不支持的

  上图中 irmovq 的 F 表示一个不访问任何寄存器, 即空占位(因为Y86中没有r15(0xf))

- OPq 为整数操作指令, Y86 中仅支持操作整数. OPq 有4种分别是 addq, subq, andq, xorq, 它们由图中 fn(依次顺序对应0-3)来区分, 在计算结束后还会设置 ZF SF OF 三个条件码

  > x86 还支持对内存数据进行操作, 不过Y86不支持

- jXX 为跳转指令有7种, 由fn区分. jmp jle jl je jne jge jg. 同x86-64的分支条件, 根据条件码和指令类型进行跳转
- cmovxx 为条件传送指令有6种, 由fn区分, cmovle, cmovl, cmove, cmovne, cmovge, cmovg

> 下图为 x86 支持的内存传送指令, Y86 仅支持基地址+偏移量的方式

![20230629140915](https://raw.githubusercontent.com/learner-lu/picbed/master/20230629140915.png)

上面提到了 4 种整数操作指令, 7 种跳转指令和 6 种条件传送指令的 fn 对应值如下图所示

![20230629150010](https://raw.githubusercontent.com/learner-lu/picbed/master/20230629150010.png)

跳转的条件码判断如下图所示, 和 x86 完全相同

![20230629132011](https://raw.githubusercontent.com/learner-lu/picbed/master/20230629132011.png)

寄存器数字编号与名称对应值如下图所示, F 代表无寄存器

![20230629150035](https://raw.githubusercontent.com/learner-lu/picbed/master/20230629150035.png)

最后我们整体观察一下 Y86 指令集特点: 0 字节用于区分指令类型, 有的指令需要附加的寄存器指示符字节, 有的还需要操作数.这些寄存器字段称为rA和rB。从指令的汇编代码表示中可以看到，根据指令类型，指令可以指定用于数据源和目的的寄存器，或是用于地址计算的基址寄存器。没有寄存器操作数的指令，例如分支指令和call 指令，就没有寄存器指示符字节。那些只需要一个寄存器操作数的指令(irmovq、pushq和 popq)将另一个寄存器指示符设为0xF。这种约定在我们的处理器实现中非常有用。

有些指令需要附加一个 4 字节的常数字, 作为立即数数据/地址偏移量/目的地址, **值得注意的是作为目的地址的时候是一个绝对地址**, 而不是像 IA32 一样使用 PC 相对地址. 同时对于整数使用了小端序.

> 例如，用十六进制来表示指令rmmovq %rsp,0x123456789abcd (%rdx)的字节编码。其中rrmmovq的第一个字节为40。源寄存器%rsp应该编码放在rA字段中，而基址寄存器%rdx应该编码放在rB字段中。查表得到寄存器指示符字节 42。最后，偏移量编码放在8字节的常数字中。首先在Ox123456789abcd的前面填充上0变成8个字节，变成字节序列00 012345 67 89 ab cd。写成按字节反序就是cd ab 89 67 45 23 01 00。将它们都连接起来就得到指令的编码 `4042cdab896745230100`

![20230629132220](https://raw.githubusercontent.com/learner-lu/picbed/master/20230629132220.png)

**指令集的一个重要性质就是字节编码必须有唯一的解释**。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。Y86-64就具有这个性质，因为每条指令的第一个字节有唯一的代码和功能组合，给定这个字节，我们就可以决定所有其他附加字节的长度和含义。

这个性质保证了处理器可以无二义性地执行目标代码程序。即使代码嵌入在程序的其他字节中，只要从序列的第一个字节开始处理，我们仍然可以很容易地确定指令序列。反过来说，如果不知道一段代码序列的起始位置，我们就不能准确地确定怎样将序列划分成单独的指令。对于试图直接从目标代码字节序列中抽取出机器级程序的反汇编程序和其他一些工具来说，这就带来了问题。

同x86-64中的指令编码相比，Y86-64的编码简单得多，但是没那么紧凑。在所有的Y86-64指令中，寄存器字段的位置都是固定的，而在不同的x86-64指令中，它们的位置是不一样的。x86-64可以将常数值编码成 1、2、4或8个字节，**而Y86-64总是将常数值编码成8个字节**。
